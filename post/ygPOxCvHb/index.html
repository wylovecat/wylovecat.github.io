<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>树 | 咸鱼爱学习</title>
<meta name="description" content="温故而知新">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="https://wylovecat.github.io//favicon.ico?v=1588229439150">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://unpkg.com/papercss@1.6.1/dist/paper.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://wylovecat.github.io//styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


  </head>
  <body>
  
    <nav class="navbar border fixed split-nav">
  <div class="nav-brand">
    <h3><a href="https://wylovecat.github.io/">咸鱼爱学习</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
      <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
        
          <li>
            
              <a href="/" class="menu">
                首页
              </a>
            
          </li>
        
          <li>
            
              <a href="/archives" class="menu">
                归档
              </a>
            
          </li>
        
          <li>
            
              <a href="/tags" class="menu">
                标签
              </a>
            
          </li>
        
          <li>
            
              <a href="/post/about" class="menu">
                关于
              </a>
            
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div id="top" class="row site">
      <div class="sm-12 md-8 col">
        <div class="paper">
          <article class="article">
            <h1>树</h1>
            <p class="article-meta">
              2019-09-15
              
                <a href="https://wylovecat.github.io/tag/GyyF0zlSG/" class="badge warning">
                  数据结构
                </a>
              
                <a href="https://wylovecat.github.io/tag/Xml2KtR4g/" class="badge ">
                  算法
                </a>
              
            </p>
            
            <div class="post-content">
              <h1 id="导入">导入</h1>
<p>线性数据结构(栈、队列)描述的时一对一的前后相继的逻辑关系，当数据之间的逻辑关系不仅仅限于一对一的线性关系出现一对多逻辑关系或多对多逻辑关系的时候，就需要用非线性数据结构来描述。</p>
<h2 id="线性结构">线性结构</h2>
<p>不管其存储方式（顺序和链式）如何，数据元素的逻辑位置之间成线性关系，即每一个数据元素通常只有一个前驱（第一个元素除外）和一个后继（除最后一个元素外）。</p>
<h2 id="非线性结构">非线性结构</h2>
<p>至少存在一个结点（数据元素）有多于一个前驱或后继的数据结构称为非线性结构。</p>
<h1 id="树的定义">树的定义</h1>
<p>树(tree)是n(n&gt;=0)个结点的有限集。n=0时成为空树。在任意以可非空树中：</p>
<ol>
<li>有且仅有一个特定的成为根(Root)的结点</li>
<li>当n&gt;1时，其余结点可分为m（m&gt;0）个互不相交的有限集T1,T2、...、Tm,其中每一个集合本身又是一棵树，并成为根的子树(SubTreee)。</li>
</ol>
<h2 id="结点分类">结点分类</h2>
<p>树的结点包含一个数据元素及若干指向其子树的分支。<br>
**结点的度：**结点拥有的子树数。度为0的结点称为叶结点或终端结点。<br>
**树的度：**时属内各结点的度的最大值</p>
<ol>
<li>根结点<br>
没有父亲的结点。在数中有且仅有一个根结点</li>
<li>分支结点<br>
除根结点外，有孩子的结点称为分支结点。</li>
<li>叶结点<br>
没有孩子的结点称为叶。<br>
根结点到每一个分支结点或叶结点的路径是唯一的。<br>
从根r到结点i的唯一路径为rcti。</li>
</ol>
<h2 id="树的其他相关概念">树的其他相关概念</h2>
<h3 id="结点的层次level">结点的层次（Level）</h3>
<p>从根开始定义起，根为第一层，根的孩子为第二层。</p>
<h3 id="树的深度或高度">树的深度或高度</h3>
<p>数中结点的最大层次</p>
<h3 id="有序树-无序树">有序树、无序树</h3>
<p>如果将数中结点的格子数堪称从左只有是有次序的，不能互换的，则称该树为有序树，否则称为无序树。</p>
<h3 id="森林">森林</h3>
<p>是m（m&gt;=0）颗互不相交的树的集合。</p>
<h1 id="树的表示方法和存储结构">树的表示方法和存储结构</h1>
<h2 id="树的表示方法">树的表示方法</h2>
<h3 id="自然界的树形表示法">自然界的树形表示法</h3>
<p>用结点和边表示树。树形表示法一般用于分析问题。<br>
<img src="https://iimg.com.cn/p/88461ff424222.png" alt="Image _11_.png" loading="lazy"></p>
<h3 id="括号表示法">括号表示法</h3>
<p>先将根结点放入一对圆括号中，然后把它的子树按由左而右的顺序·放入括号中，而对子树也采用同样方法处理：同层子树与他的根节点用圆括号括起来，同层子树之间用逗号隔开，最后用比括号括起来。<br>
如图可写成如下形式：<br>
(r (a (w,x (d (h) ,e)),b(f),c(s,t(i(m,o,n),j),u)))</p>
<h2 id="树的存储结构">树的存储结构</h2>
<h3 id="静态的记录数组顺序存储">静态的记录数组（顺序存储）</h3>
<p>所有结点存储在一个数组中，数组元素为记录数据的变量和长度为n（树的度）的数组，数据变量用于存储结点数据，数组用来存储该结点的每一个子结点的下标。</p>
<h3 id="动态的链表存储结构链式存储">动态的链表存储结构（链式存储）</h3>
<p>动态的链表存储结构，建立一个单链表，链表的每一份结点都有记录数据的变量和指针变量，数据变量用于存储结点数据，指针变量用于指向起子结点。</p>
<h1 id="二叉树的概念">二叉树的概念</h1>
<p>二叉树（Binary Tree）是n(n&gt;=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者有一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p>
<h2 id="特点">特点</h2>
<p>每个节点最多有两棵子树<br>
左子树和右子树是有区分的</p>
<h2 id="和树的区别">和树的区别</h2>
<p>1.树的每一个结点可以有任意多个，而二叉树没有节点的后继不超过2个<br>
2.树的子树可以部分次序（除有序树外）；而二叉树的子树有左右之分。我们成二叉树的左后件为左儿子，右后件为右儿子。</p>
<h2 id="五种形态">五种形态</h2>
<ol>
<li>空二叉树</li>
<li>只有一个根节点</li>
<li>根结点只有左子树</li>
<li>根结点只有右子树</li>
<li>根结点既有左子树又有右子树</li>
</ol>
<h2 id="特殊的二叉树">特殊的二叉树</h2>
<h3 id="斜树">斜树</h3>
<p>所有的结点都只有左子树的二叉树叫左斜树。所有结点都只有右子树的二叉树叫右斜树。这两者统称为斜树。线性表结构可以理解为是树的一种极其特殊的表现形式</p>
<h3 id="满二叉树">满二叉树</h3>
<p>在一棵树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p>
<h4 id="满二叉树特点">满二叉树特点</h4>
<ol>
<li>叶子只能出现在最下一层</li>
<li>非叶子节点的度一定是2</li>
<li>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</li>
</ol>
<h3 id="完全二叉树">完全二叉树</h3>
<p>对一棵具有n个结点的二叉树按层序编号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这颗二叉树被称为完全二叉树。<br>
满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。</p>
<h4 id="特点-2">特点</h4>
<ol>
<li>叶子结点只能出现在最下两层</li>
<li>最下层的叶子一定集中在左部连续位置</li>
<li>倒数二层，若有叶子结点，一定都在右部连续位置</li>
<li>如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。</li>
<li>同样结点数的二叉树，完全二叉树的深度最小。</li>
</ol>
<h1 id="二叉树的性质">二叉树的性质</h1>
<h2 id="性质1">性质1</h2>
<p>在二叉树的第i层上之多有2^(i-1)个结点</p>
<h2 id="性质2">性质2</h2>
<p>深度设为k的二叉树至多有2^(k)-1个结点(k&gt;=1)</p>
<h2 id="性质3">性质3</h2>
<p>对任何一棵二叉树T,如果起终点结点树为n0,度为2的结点数位n2,则n0=n2+1;叶子结点数总比度为2的结点多1.</p>
<h2 id="性质4">性质4</h2>
<p>具有n个结点的完全二叉树的深度位{log2(n)}+1,{x}表示不大于x的最大整数(向下取整)。</p>
<h1 id="二叉树的存储结构">二叉树的存储结构</h1>
<h2 id="顺序存储结构">顺序存储结构</h2>
<p>用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系。<br>
每个结点的信息包括</p>
<ol>
<li>数据域（data）</li>
<li>两个指针域，其中有父节点层号，子结点层号</li>
</ol>
<pre><code>struct position
{
    char data;//数据
    int level ,order;//结点的层，本层的序号（满二叉树计算方式）
};
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://iimg.com.cn/p/061ef32482110.png" alt="Image.png" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://iimg.com.cn/p/1f829052c0d1f.png" alt="Image _2_.png" loading="lazy"></figure>
<p>一般用于完全二叉树或满二叉树。<br>
对于非完全二叉树来说，需要添加一些不曾在的空结点使之变成完全二叉树使下标之间准确反映树中结点间的逻辑关系。但会造成空间的浪费，在斜树中尤为严重。</p>
<h2 id="链式存储结构">链式存储结构</h2>
<p>二叉树是每个结点最多拥有两个孩子，所以为它设计一个数据域和两个指针与是比较自然的想法，我们称这样的链表叫做二叉链表。<br>
<img src="https://iimg.com.cn/p/1b5e3bf36037e.png" alt="Image _3_.png" loading="lazy"></p>
<pre><code>typedef struct node {
    char data;
    struct node *lchild;
    struct node *rchild;
}node;
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://iimg.com.cn/p/5b0374a058e51.png" alt="Image _4_.png" loading="lazy"></figure>
<h1 id="二叉树的遍历">二叉树的遍历</h1>
<p>二叉树的遍历时不重复地访问二叉树中地每一个结点。在访问到每个结点时，可以去除结点中的信息，或对结点作其他的处理。<br>
如果用L、D、R分别表示遍历左子树、根结点、右子树。限定先左后右的次序，有</p>
<h2 id="前序遍历dlr">前序遍历DLR</h2>
<p>规则时若二叉树为空，则空操作返回</p>
<ol>
<li>访问根结点</li>
<li>前序遍历左子树</li>
<li>前序遍历右子树</li>
</ol>
<pre><code>void preOrderTraverse(node * T)
{
    if(T==NULL)
        return ;
    cout&lt;&lt;T-&gt;data;//访问结点
   preOrderTraverse(T-&gt;lchild);
    preOrderTraverse( T-&gt;rchild);
    
}
</code></pre>
<h2 id="中序遍历ldr">中序遍历LDR</h2>
<p>若树为空，则空操作返回，否则从根结点开始（不是访问）</p>
<ol>
<li>中序遍历左子树</li>
<li>访问根结点</li>
<li>中序遍历右子树</li>
</ol>
<pre><code>void inOrderTraverse(node * T)
{
    if(T==NULL)
        return ;
    
    inOrderTraverse(T-&gt;lchild);
    cout&lt;&lt;T-&gt;data;//访问结点
    inOrderTraverse( T-&gt;rchild);
    
}
</code></pre>
<h2 id="后序遍历lrd">后序遍历LRD</h2>
<p>若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历左右子树，最后访问根结点。</p>
<pre><code>void postOrderTraverse(node * T)
{
    if(T==NULL)
        return ;
    
    postOrderTraverse(T-&gt;lchild);
    postOrderTraverse( T-&gt;rchild);
    cout&lt;&lt;T-&gt;data;//访问结点
    
}
</code></pre>
<h2 id="层序遍历">层序遍历</h2>
<p>若树为空，则空操作返回。否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p>
<h2 id="为什么要有那么多遍历方法">为什么要有那么多遍历方法</h2>
<p>对于计算机来说，他只有循环，判断等方式处理。只会处理线性的序列，这些遍历方法都能将树中的结点变成某种意义上的线性序列，给程序实现带来了好处。</p>
<h1 id="推导遍历结果">推导遍历结果</h1>
<p>已知前序遍历和中序遍历序列，可以唯一确定一棵二叉树<br>
已知后续遍历和中序遍历序列，可以唯一确定一棵二叉树</p>
<p>已知前序和后序遍历，是不能确定一棵二叉树的，原因是我们无法知道哪个结点是左右子树。</p>
<h1 id="二叉树的建立">二叉树的建立</h1>
<p>用遍历的方式进行树的生成，将访问操作改成生成结点，给结点赋值。</p>
<h1 id="线索二叉树">线索二叉树</h1>
<h2 id="原理">原理</h2>
<ol>
<li>指针域并不是都充分利用了，有许许多多的空指针域存在。有n个结点的二叉链表，一共有2n个指针域。一共有n-1条分支线数，存在2n-(n-1)=n+1个空指针域。存在空间的浪费</li>
<li>在遍历时，在遍历之后我们可以清楚的知道某节点的前驱后继是哪一个，可这是建立在已经遍历过的基础上的。在二叉链表上只能知道孩子是谁，无法知道前驱后继。以后每次向知道都得进行遍历。</li>
</ol>
<p>若考虑在创建时就记录下前驱后继，则将节省大量时间。<br>
可利用空指针域，存放指向结点在某种遍历次序下的前驱和后继结点的地址。<br>
我们把这种指向前驱和后继的指针称为线索，加上线索的二叉链表陈伟线索链表，相应的二叉树就称为线索二叉树(Threaded Binary Tree).<br>
<img src="https://iimg.com.cn/p/1b76b4c007cef.png" alt="Image _5_.png" loading="lazy"><br>
将所有的空指针域中的rchild改为指向它的后继结点。<br>
<img src="https://iimg.com.cn/p/1def4d0688d1b.png" alt="Image _6_.png" loading="lazy"></p>
<p>lchild改为指向当前结点的前驱。<br>
<img src="https://iimg.com.cn/p/3faf36dee0322.png" alt="Image _7_.png" loading="lazy"></p>
<p>对二叉树以某种次序遍历使其变成线索二叉树的过程称作是线索化。</p>
<h2 id="新的问题">新的问题</h2>
<p>如何知道某一结点的指针究竟是指向孩子还是指向前驱后继的？，需要一个区分标记。<br>
增设两个标志域ltag和rtag，他们只存放0或1（可以bool型）。</p>
<ul>
<li>ltag为0时指向该节点的左孩子，为1时指向该节点的前驱</li>
<li>rtag为0时指向该节点的右孩子，为1时指向该节点的后继</li>
</ul>
<p><strong>线索化的过程就是在遍历的过程中修改空指针的过程</strong></p>
<p>有了线索二叉树后，对他进行遍历时发现，其操作就等于是操作一个双向链表结构。<br>
如果所有的二叉树经常需要遍历或查找结点时需要某种遍历序列中的前驱后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</p>
<h1 id="树-森林与二叉树的转换">树、森林与二叉树的转换</h1>
<p>森林：是m（m&gt;=0）颗互不相交的树的集合</p>
<h2 id="将树转换为二叉树">将树转换为二叉树</h2>
<ol>
<li>加线。在所有兄弟节点之间加一条线</li>
<li>去线。对树中每个节点，只保留它与第一个孩子（长子）结点的连线，删除它与其他孩子结点之间之间的连线。</li>
<li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子时二叉树结点的左孩子，兄弟转换过来的孩子时结点的右孩子。</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://iimg.com.cn/p/75c868f97a7c9.png" alt="Image _8_.png" loading="lazy"></figure>
<h2 id="森林转化为二叉树">森林转化为二叉树</h2>
<p>森林是由若干棵树组成的，所以可以理解成森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。</p>
<ol>
<li>把每个树转化为二叉树</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一颗二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。<br>
<img src="https://iimg.com.cn/p/eaa88cbabd495.png" alt="Image _9_.png" loading="lazy"></li>
</ol>
<h2 id="二叉树转换为树">二叉树转换为树</h2>
<p>是树转化为二叉数的逆过程，反过来做即可。</p>
<ol>
<li>加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用先连起来。</li>
<li>去线。删除原二叉树中所有结点与其右孩子结点的连线</li>
<li>层次调整。使之结构层次分明。<br>
<img src="https://iimg.com.cn/p/455caefc08c2d.png" alt="Image _10_.png" loading="lazy"></li>
</ol>
<h2 id="二叉树转换成森林">二叉树转换成森林</h2>
<p>判断一棵二叉树能够转换成一棵树还是森林，标准很简单，只要看这颗二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。</p>
<ol>
<li>从根节点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除......，直到所有有孩子连线都删除位置，得到分离的二叉树。</li>
<li>再将每棵分离后的二叉树转换为树即可。</li>
</ol>

            </div>
          </article>
        </div>
        <div class="paper" data-aos="fade-in">
          
            <div class="next-post">
              <div class="next">
                下一篇
              </div>
              <a href="https://wylovecat.github.io/post/m6Tq0iSbX/">
                <h3 class="post-title">
                  快速排序
                </h3>
              </a>
            </div>
          
        </div>
        
          
            <div class="paper" data-aos="fade-in">
              <div id="gitalk-container"></div>
            </div>
          

          
        
      </div>

      <div class="sm-12 md-4 col sidebar">
  <div class="paper info-container">
    <img src="https://wylovecat.github.io//images/avatar.png?v=1588229439150" class="no-responsive avatar">
    <div class="text-muted">温故而知新</div>
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      最新文章
    </div>
    <div class="row">
      <ul>
        
          
            <li>
              <a href="https://wylovecat.github.io/post/GmnQXK1ZW/">信息学奥赛一本通_1133_输出亲朋字符串</a>
            </li>
          
        
          
            <li>
              <a href="https://wylovecat.github.io/post/5Ewb0MPXV/">算法效率分析</a>
            </li>
          
        
          
            <li>
              <a href="https://wylovecat.github.io/post/lU9_cI8hL/">引用变量相关</a>
            </li>
          
        
          
            <li>
              <a href="https://wylovecat.github.io/post/k_wx6EVNW/">最长上升子序列</a>
            </li>
          
        
          
            <li>
              <a href="https://wylovecat.github.io/post/sH4qfqRNg/">高精度计算（三）</a>
            </li>
          
        
          
            <li>
              <a href="https://wylovecat.github.io/post/4TikL8fmo/">高精度计算（二）</a>
            </li>
          
        
          
            <li>
              <a href="https://wylovecat.github.io/post/aTb47DjFP/">题解：进制转换</a>
            </li>
          
        
          
            <li>
              <a href="https://wylovecat.github.io/post/oJfUmYKbM/">利用码云Gitee和PicGo搭建自己的免费图床</a>
            </li>
          
        
          
            <li>
              <a href="https://wylovecat.github.io/post/-0ZTKQ856/">Lepton使用手册</a>
            </li>
          
        
          
            <li>
              <a href="https://wylovecat.github.io/post/WntCGkdyK/">题解：完数的判断（C++描述）</a>
            </li>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </ul>
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      标签列表
    </div>
    <div class="row">
      
        <a href="https://wylovecat.github.io/tag/FNlWtNQpA/" class="badge ">
          题解
        </a>
      
        <a href="https://wylovecat.github.io/tag/S-CLh9EEX/" class="badge secondary">
          枚举
        </a>
      
        <a href="https://wylovecat.github.io/tag/Xml2KtR4g/" class="badge secondary">
          算法
        </a>
      
        <a href="https://wylovecat.github.io/tag/CSNe-Ttwm/" class="badge success">
          C/C++
        </a>
      
        <a href="https://wylovecat.github.io/tag/zjXnb_eXv/" class="badge secondary">
          noip
        </a>
      
        <a href="https://wylovecat.github.io/tag/iqjH4VeE6/" class="badge secondary">
          高精度
        </a>
      
        <a href="https://wylovecat.github.io/tag/cKlT30oiM/" class="badge secondary">
          模拟
        </a>
      
        <a href="https://wylovecat.github.io/tag/Z3tt3bzbS/" class="badge secondary">
          数学
        </a>
      
        <a href="https://wylovecat.github.io/tag/M0JrCmklM/" class="badge success">
          markdown
        </a>
      
        <a href="https://wylovecat.github.io/tag/Vy35u5qbs/" class="badge ">
          工具
        </a>
      
        <a href="https://wylovecat.github.io/tag/GyyF0zlSG/" class="badge warning">
          数据结构
        </a>
      
        <a href="https://wylovecat.github.io/tag/tHyJk6N28/" class="badge warning">
          Git
        </a>
      
        <a href="https://wylovecat.github.io/tag/sEMfEVAVO/" class="badge secondary">
          计算机基础
        </a>
      
        <a href="https://wylovecat.github.io/tag/markdown/" class="badge success">
          Markdown
        </a>
      
        <a href="https://wylovecat.github.io/tag/4kipjvQ-w/" class="badge warning">
          vscode
        </a>
      
        <a href="https://wylovecat.github.io/tag/RYJKhhSlc/" class="badge secondary">
          hexo
        </a>
      
        <a href="https://wylovecat.github.io/tag/gridea/" class="badge warning">
          Gridea
        </a>
      
    </div>
  </div>
  <div class="paper">
    Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://wylovecat.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>


    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '09eba599fe2352041699',
        clientSecret: '87b54f3fac03f239dfa5a92f9a96207f3f57139f',
        repo: 'wylovecat.github.io',
        owner: 'wylovecat',
        admin: ['wylovecat'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
