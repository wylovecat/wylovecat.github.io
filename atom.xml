<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wylovecat.github.io/</id>
    <title>咸鱼爱学习</title>
    <updated>2019-09-02T15:25:16.524Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wylovecat.github.io/"/>
    <link rel="self" href="https://wylovecat.github.io//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://wylovecat.github.io//images/avatar.png</logo>
    <icon>https://wylovecat.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 咸鱼爱学习</rights>
    <entry>
        <title type="html"><![CDATA[欧几里得算法与拓展欧几里得]]></title>
        <id>https://wylovecat.github.io//post/jZSzkJ5Oq</id>
        <link href="https://wylovecat.github.io//post/jZSzkJ5Oq">
        </link>
        <updated>2019-09-02T15:21:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="欧几里得算辗转相除法">欧几里得算(辗转相除法)</h1>
<h2 id="算法描述">算法描述</h2>
<p>设 a&gt;=b</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>÷</mo><mi>b</mi><mo>=</mo><mi>k</mi><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">a \div b = k ······ r    
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span></span></p>
<p>a和b的最大公约数等于b和r的最大公约数。<br>
gcd(a,b)=gcd(b,a%b),当b为0时，a为(a,b)最大公约数</p>
<h2 id="c实现">C++实现</h2>
<pre><code>//递归方式
int gcd(int a,int b)
{
    if(b==0) return a;
    else return gcd(b,a%b);
}

//非递归方式
while(b!=0)
{
    int r=a%b;
    a=b;
    b=r;
}
cout&lt;&lt;a;
</code></pre>
<h2 id="定理证明">定理证明</h2>
<ol>
<li>证明a,b的公约数和 b,r的公约数相同,就能证明最大公约数相同
<ol>
<li>设a = kb+r (a&gt;=b)。由假设可知，r=a mod b。</li>
<li>设d为a和b的任意公约数。</li>
<li>变形可得到式子：r=a-kb,等式两边同除d,可得到式子： r/d = a/d - kb/d =m。</li>
<li>因为d为a,b的公约数，故a/d 为整数，b/d为整数，故r/d也为整数,可推出d为r的约数。故d是b和r的约数。</li>
<li>所以，a和b的任意公约数d,也是b和a%b的公约数。</li>
<li>设 d 是 b,a%b的公约数，则d是b和a-kb的公约数</li>
<li>设b=xd, a-kb=yd（d是他们的约数，他们则可写成d的倍数形式）。则存在a=kb+yd;</li>
<li>将等式两边同除d,a/d =kb/d + y=m。y是整数，d是b的约数，所以m未整数，即d是a的约数。</li>
<li>所以d也是a和b的公约数</li>
<li>综上，(a,b)和(b,a%b)的公约数集合相同，证得(a,b)和(b,a%b)的公约数是一样的</li>
<li>所以最大公约数也相同，证明gcd(a,b)=gcd(b,a%b)</li>
</ol>
</li>
</ol>
<h1 id="拓展欧几里得算法">拓展欧几里得算法</h1>
<h2 id="定理">定理：</h2>
<p>给予两个整数a、b,必存在整数x,y使得ax + by = gcd(a,b)。（贝祖等式）<br>
拓展欧几里得算法就是再辗转相除法的基础上，求的改等式的通解。<br>
x=x0+(b/gcd(a,b)) * t<br>
y=y0-(a/gcd(a,b)) * t<br>
我们知道：a%b = a - (a/b) * b,所以我可以进一步得到<br>
gcd(a,b) = gcd(b, a%b) :<br>
gcd(a%b)=b * x1 + ( a - (a/b)* b)* y1<br>
=b <em>x1 + a</em>y1-(a/b)<em>b</em>y1<br>
= a * y1 +b*(x1-a/b<em>y1)<br>
观察可以发现，x=y1,y=x1-a/b</em> y1<br>
所以我们只要在求解欧几里得的时候同时加上对x,y的更新即可。考虑边界情况，当b=0时，显然此时x=1,y=0;</p>
<h2 id="代码实现">代码实现</h2>
<pre><code>int ex_gcd(int a,int b,int &amp;x,int &amp;y)
{
   if(b==0) {x=1;y=0;return a;}
   int ans=ex_gcd(b,a%b,x,y);
   int t=x;
   x=y;
   y=t-a/b*y;
   return ans;
 }
 
 //精简
 int ex_gcd(int a,int b,int &amp;x,int &amp;y)
 {
   if(b==0) {x=1;y=0;return a;}
   int ans=ex_gcd(b,a%b,y,x);
   y-=(a/b)*x;
   return ans;
 }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[比例简化]]></title>
        <id>https://wylovecat.github.io//post/dLtINUDHC</id>
        <link href="https://wylovecat.github.io//post/dLtINUDHC">
        </link>
        <updated>2019-08-17T02:19:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目阅读">题目阅读</h3>
<p><a href="https://turingjudge.com/problem/1805">比例简化</a></p>
<h3 id="分析">分析</h3>
<p>现给出支持人数A，反对人数B，以及一个上限L，请你将A比B化简为A’比B’，要求在A’和B’均不大于L且A’和B’互质（两个整数的最大公约数是1）的前提下，A’/B’≥ A/B且A’/B’- A/B的值尽可能小</p>
<p>整理几个关键信息点</p>
<ul>
<li>在A’和B’均不大于L且A’和B’互质</li>
</ul>
<p>a&lt;=L &amp;&amp; b&lt;=L &amp;&amp; gcd(a,b)==1</p>
<ul>
<li>A’/B’≥ A/B且A’/B’- A/B的值尽可能小</li>
</ul>
<p>a/b&gt;=A/B =&gt; a * B &gt;= A *  b &amp;&amp;  a/b 尽可能小</p>
<p>分析下来就是一道枚举题目，寻找满足条件的最小的a/b的值最小的那对a,b;变成了最值寻找问题</p>
<pre><code class="language-c++">int min=max;
for( )
{
	if(num&lt;min)
	{
		min=num;
	}
}
cout&lt;&lt;num;
</code></pre>
<pre><code class="language-c++">ta=L,tb=1;
for(int a=1;a&lt;=L;a++)
{
    for(int b=L;b&gt;=1;b--)
    {
        if(gcd(a,b)==1 &amp;&amp; a*B&gt;=A*b &amp;&amp; a*tb&lt;ta*b)
        {
            ta=a;
            tb=b;
            break;
        }
    }
}
cout&lt;&lt;ta&lt;&lt;&quot; &quot;&lt;&lt;tb;
</code></pre>
<h3 id="ac代码">AC代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
/*
 * a&lt;=L&amp;&amp;b&lt;=L&amp;&amp;gcd(a,b)==1
 *  a/b&gt;=A/B =》 a*B &gt;= A*b  &amp;&amp; a/b - A/B 尽可能小
 *  1~100 =》 L   a/b&lt;=L   a&lt;=L*b   b&gt;=a/L
 *
 *  a/b &lt;ta/tb
 *
 *  枚举
 * */

int gcd(int a,int b)
{
    while(b!=0)
    {
        int r=a%b;
        a=b;
        b=r;
    }
    return a;
}
int main(){

    int A,B,L;
    cin&gt;&gt;A&gt;&gt;B&gt;&gt;L;
    int y=gcd(A,B);
    A/=y;
    B/=y;
    int ta=L;
    int tb=1;
    for(int a=1;a&lt;=L;a++)
    {
        for(int b=L;b&gt;=a/L;b--)
        {
            if(gcd(a,b)==1 &amp;&amp; a*B&gt;=A*b &amp;&amp; a*tb&lt;=ta*b)
            {
                ta=a;
                tb=b;
                break;
            }
        }
    }
    cout&lt;&lt;ta&lt;&lt;&quot; &quot;&lt;&lt;tb;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[珠心算测验]]></title>
        <id>https://wylovecat.github.io//post/S-SCKDM5o</id>
        <link href="https://wylovecat.github.io//post/S-SCKDM5o">
        </link>
        <updated>2019-08-15T07:14:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p><a href="https://turingjudge.com/problem/1804">珠心算测验</a></p>
<h2 id="阅读与分析">阅读与分析</h2>
<p>集合中的各个与手持不相同。求有多少个数恰好等于集合中另外两个（不同的）数之和。</p>
<p>注意：题目求的是数字的个数不是，满足条件的式子的个数入，3+4=7，2+5=7，个数只有1不是2。</p>
<p>整体分析下来是将不同的两数相加，将结果和剩下的数字比对，不同的就统计下即可。</p>
<pre><code class="language-c++">for(i:0~n)
{
	for(j:i~n)
	{
		for(k:j~n)
		{
			if(i+j==k &amp;&amp; num[k]==0)
			{
				s++;
				num[k]=1;
			}
		}
	}
}
</code></pre>
<h2 id="ac-代码">AC 代码</h2>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;
int num[10005]={0};
int a[200]={0},n;

int main() {
    int s=0;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;a[i];
        num[a[i]]=1;
    }

    for(int i=1;i&lt;=n;i++)
    {
        for(int j=i+1;j&lt;=n;j++)
        {
            int m=a[i]+a[j];
            if(m&lt;=10000 &amp;&amp; num[m]==1)// 限制总和范围，不然会越界
            {
                s++;
                num[m]=2;
            }
        }
    }
    cout&lt;&lt;s;


    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[回文日期]]></title>
        <id>https://wylovecat.github.io//post/8o-Bcw0Hg</id>
        <link href="https://wylovecat.github.io//post/8o-Bcw0Hg">
        </link>
        <updated>2019-08-15T05:46:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p><a href="https://turingjudge.com/problem/1846">回文日期</a></p>
<h2 id="阅读与分析">阅读与分析</h2>
<p>用8位数字表示日期，前4位表示年份，接下来2位表示月份，最后2位代表日期。对范围内的日期进行回文日期的统计。若一个日期是回文的，当且仅当对于所有的i从左向有的第i个数字和第9-i个数字是相同的。</p>
<p>输入起止日期，统计多少个日期是回文的。</p>
<p>阅读下来，题目梗概即为在一定范围内统计符合条件的数字个数，即可想到使用枚举法进行处理</p>
<p>基本框架如下。</p>
<pre><code class="language-c++">for(int i:date1~date2)
{
	if(isPali(i))
	{
		num++;
	}
}
</code></pre>
<p>问题变成，如何判断一个日期是回文的。</p>
<p>一个思路是将8位数日期的倒序数求出将倒序数与原数比较，相等即是回文。</p>
<p>另一个思路，将回文日期列举，能发现 20100102，20111102，月日组成的倒数和年相等即是回文。</p>
<p>此外需要注意，日期必须得是真实存在的。修改框架如下：</p>
<pre><code class="language-c++">for(int i:date1~date2)
{
	if(isReal(i)&amp;&amp;isPali(i))
	{
		num++;
	}
}
</code></pre>
<h2 id="ac代码">AC代码</h2>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

int months[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};

bool isLeap(int year)
{
    return (year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0;
}

bool isPali(int date)
{
    int y=date/10000;

    int reserve=0;
    while(date!=y)
    {
        int u=date%10;
        date/=10;
        reserve= reserve * 10 + u;
    }
    return reserve == y;

}

bool isReal(int date)
{
    int y=date/10000;
    int m=date/100%100;
    int d=date%100;

    if(isLeap(y))
    {
        months[2]=29;
    }else
    {
        months[2]=28;
    }

    return (m &gt;= 1 &amp;&amp; m &lt;= 12) &amp;&amp; (d &gt;= 1 &amp;&amp; d &lt;= months[m]);
}

int main() {

    int date1,date2,num=0;
    cin&gt;&gt;date1&gt;&gt;date2;
    for(int i=date1;i&lt;=date2;i++)
    {
        if(isReal(i)&amp;&amp;isPali(i))
        {
            num++;
        }
    }
    cout&lt;&lt;num;

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[有趣的GitHub项目]]></title>
        <id>https://wylovecat.github.io//post/UukfogPTY</id>
        <link href="https://wylovecat.github.io//post/UukfogPTY">
        </link>
        <updated>2019-07-14T07:44:23.000Z</updated>
        <summary type="html"><![CDATA[<p>分享一些有趣、有用的GitHub项目。</p>
]]></summary>
        <content type="html"><![CDATA[<p>分享一些有趣、有用的GitHub项目。</p>
<!--more-->
<h3 id="git的奇技淫巧">Git的奇技淫巧</h3>
<p>https://github.com/521xueweihan/git-tips</p>
<p>列举了Git常用的命令和一些小技巧。</p>
<h3 id="gridea">Gridea</h3>
<p>https://github.com/getgridea/gridea</p>
<p>一个静态博客写作客户端。用了它我就抛弃了Hexo。作者更新的很勤快。</p>
<h3 id="待续">待续</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用fgets()替换gets()]]></title>
        <id>https://wylovecat.github.io//post/Y4cNdIzTy</id>
        <link href="https://wylovecat.github.io//post/Y4cNdIzTy">
        </link>
        <updated>2019-05-06T09:10:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="原因">原因</h3>
<blockquote>
<p>gets()函数不太安全，容易出现数组溢出问题。</p>
</blockquote>
<h3 id="举例">举例：</h3>
<pre><code>char name[3];
gets(name);

假设我输入&quot;wangxiaoming&quot;，很明显长度超出限制，但是gets()不会对其进行检查。
</code></pre>
<p><strong>使用fgets()来进行更安全的输入。</strong></p>
<h3 id="描述">描述</h3>
<blockquote>
<p>C 库函数 char <em>fgets(char</em> str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</p>
</blockquote>
<h3 id="声明">声明</h3>
<p>下面是 fgets() 函数的声明。</p>
<blockquote>
<p>char <em>fgets(char</em> str, int n, FILE *stream)</p>
</blockquote>
<h3 id="参数">参数</h3>
<p><strong>str</strong> -- 这是指向一个字符数组的指针，该数组存储了要读取的字符串。</p>
<p><strong>n</strong> -- 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。</p>
<p><strong>stream</strong> -- 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。</p>
<h3 id="返回值">返回值</h3>
<ul>
<li>如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。</li>
<li>如果发生错误，返回一个空指针。</li>
</ul>
<h3 id="使用举例">使用举例</h3>
<pre><code class="language-c++">char name[len];
fgets(name,len,stdin);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[升级DevC++的编译器]]></title>
        <id>https://wylovecat.github.io//post/1M3vM-kJi</id>
        <link href="https://wylovecat.github.io//post/1M3vM-kJi">
        </link>
        <updated>2019-04-23T07:45:40.000Z</updated>
        <content type="html"><![CDATA[<hr>
<h2 id="前言">前言</h2>
<p>DevC++是采用MinGW来作为C/C++的编译器的，但是由于多年未更新，版本老旧。当然，我们可以继续使用它来进行相关内容学习，如果想对编译器进行更新可以自己下载最新版本的MinGW进行替换。</p>
<h2 id="安装mingw">安装MinGW</h2>
<p>MinGW可使用<a href="https://sourceforge.net/projects/mingw/">MinGW Installation Manager</a>进行安装，但是由于资源在境外下载速度比较慢，且在安装后发现版本是在三年前的，虽然比DevC++的新一些。所以推荐采用另一种安装方式<a href="https://nuwen.net/mingw.html#install">MinGW Distro</a>。这个是GCC 8.2.0版本的，并且要用的包全都已经打包好了，下载完成解压即可使用。下载页面分两个，如果在电脑上已经安装好Git可以下载<a href="https://nuwen.net/files/mingw/mingw-16.1-without-git.exe">without-git</a>版本，如果没有就下载<a href="https://nuwen.net/files/mingw/mingw-16.1.exe">完整</a>的就行。</p>
<p>解压完成后可手动进行环境配置，或者运行里面的自带的bat脚本进行配置。配置完成后打开命令行窗口，输入gcc -v查看版本，观察是否已经成功配置。</p>
<p><img src="https://cdn.all-dream.com/user/24ea64ea3b034d4ea442e522a4692266/20190423_154705_gcc.png" alt="gcc -v"></p>
<p>出现上图所示内容代表已经配置成功。</p>
<h2 id="替换编译器">替换编译器</h2>
<p>打开DevC++，点击工具-编译环境，在设定编译器配置时，点击第二个绿色加号（由文件夹添加编译器配置），选择我们刚刚解压的MinGW文件夹，他会自动进行配置，点击确定即可完成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[进制转换]]></title>
        <id>https://wylovecat.github.io//post/ZigeFxfIY</id>
        <link href="https://wylovecat.github.io//post/ZigeFxfIY">
        </link>
        <updated>2019-04-19T09:37:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="进制转换">进制转换</h1>
<h2 id="基础">基础</h2>
<p>十进制与二进制的转换是基础内容，应做到熟练地将十进制的数转为二进制，将二进制的数转为十进制。</p>
<h3 id="十进制转二进制">十进制转二进制</h3>
<h4 id="整数转二进制">整数转二进制</h4>
<p>整数转二进制是最常见的。核心在于除2取余，倒序排列，高位补零。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/292435/1554633400474-fdf7c01e-f32e-435f-8a9c-a75a7ec3774c.png#align=left&amp;display=inline&amp;height=332&amp;name=image.png&amp;originHeight=664&amp;originWidth=1184&amp;size=87756&amp;status=done&amp;width=592" alt="image.png"><br />不断地将数字除以2，将余数写一边，直到商为0时，停止。下方的为二进制的高位，由高位到低位倒序排列余数，高位不够用0来代替。</p>
<h4 id="负整数转二进制">负整数转二进制</h4>
<p>先是将对应的正整数转换成二进制后，对二进制取反然后再加1。以-10为例。10的二进制表达是(00001010),由于高位都是0，所以可以省略，写成(1010) ,（用B来表示表达的是二进制）。</p>
<ol>
<li>先取反。取反的意思就是1变成0，0变成1。(00001010)=&gt;(11110101)</li>
<li>加上1。由于是二进制，所以我们逢二进一。(11110101)=&gt;(11110110)</li>
</ol>
<p>由于小数的高位都是1，所以我们也可以将高位省去，只保留(0110)不过注意和正整数进行区别。</p>
<h4 id="小数转二进制">小数转二进制</h4>
<p>将小数部分乘以2，取整数(这个整数不是0就是1)，当乘以二后小数部分结果为0或者位数够了，这些整数就是二进制。<br />以0.125为例<br />0.125 * 2 =0.25 整数部分为 0<br />0.25 *  2  = 0.5  整数部分为 0<br />0.5  *  2  = 1.0  整数部分为1，小数部分为0，停止。<br />二进制就为0.001<br />如果是带整数部分的小数进行进制转换，那么分开来处理，先将整数部分，转换成二进制，再将小数部分，转为二进制。<br />**注意 **小数进行二进制转换是存在无法除尽的情况的，这是正常的。根据题意保留足够的位数即可。</p>
<h3 id="二进制转十进制">二进制转十进制</h3>
<p>使用按权相加法。</p>
<h4 id="高位为0">高位为0</h4>
<p>首先第一步将位数补齐，如果高位是0则是一个正数。将其分离位数，将分离出来的位数按从低位到高位的顺数，依次和2的冥相乘累加。以(1010)为例。<br />分离位数： 1 0 1 0  =》相乘累加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>×</mo><msup><mn>2</mn><mn>0</mn></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><mn>0</mn><mo>×</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">0\times2^{0}+1\times2^{1}+0\times2^{2}+1\times2^{3}=10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></p>
<h4 id="高位为1">高位为1</h4>
<p>如果高位为1，则说明是一个负数，那就先减1，再进行取反，在进行转换。以(11110110)<br />减一：(11110101) =&gt; 取反: (00001010)=&gt;按权相加:0<em>2+1</em>2+0<em>2+1</em>2=10</p>
<h4 id="小数形式">小数形式</h4>
<p>整数部分和小数部分分开计算。整数部分参考上面。小数部分则是相反。以（0.001）为例。<br />按权相加：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>0</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup><mo>=</mo><mn>0.125</mn></mrow><annotation encoding="application/x-tex">0\times2^{-1}+0\times2^{-2}+1\times2^{-3}=0.125</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span></span></span></span></p>
<h2 id="其他进制转换">其他进制转换</h2>
<p>整体上的方法和十进制与二进制的转换方法类似。转换成x进制的话使用除x取余，倒序排列，高位补零。二进制转换成其他进制还是采用按权相加的方法。</p>
<h3 id="八进制与十六进制">八进制与十六进制</h3>
<p>八进制是逢八进一。</p>
<p>十进制转八进制的话，过程就是不断地将数字除以8，将余数写一边，直到商为0时停止。下方的为二进制的高位，由高位到低位倒序排列余数，高位不够用0来代替。以十进制10转换为八进制例。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/292435/1554693614581-4e24b0dc-9e94-4acf-889f-89617bbcc24d.png" alt="image.png"></p>
<p>十六进制也是类似，需要注意的点是，十六进制的10<sub>15是使用A</sub>F来表示的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[递归与分治（一）]]></title>
        <id>https://wylovecat.github.io//post/Hkqr-7jgZ</id>
        <link href="https://wylovecat.github.io//post/Hkqr-7jgZ">
        </link>
        <updated>2019-03-01T02:50:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="递归基本思想">递归基本思想</h3>
<p><strong>基本要素</strong></p>
<ol>
<li>递归终止条件</li>
<li>终止处理办法</li>
<li>递归处理办法</li>
</ol>
<p><strong>递归-阶乘</strong><br>
阶乘计算：从键盘输入正整数N（0&lt;=N&lt;=20）,输出N！。</p>
<pre><code>int factorial(int n){
    if(n==0
        return 1;//递归边界
    return n*factorial(n-1);//递归调用
 }
</code></pre>
<p><strong>递归-Fibonacci</strong><br>
每对兔子每个月不多不少恰好能生一对(一雌一雄)新兔子，而且每对新生兔出生两个月后就成熟并具备生殖能力；另外，假定所有的兔子都不会死亡。假如养了出生的小兔一对，试问第n个月后共有多少对兔子?</p>
<pre><code>long fib(int n){
    if(n&lt;=1) return 1;
    return fib(n-1)+fib(n-2);
}
</code></pre>
<h3 id="递归实例">递归实例</h3>
<h4 id="全排列问题">全排列问题</h4>
<blockquote>
<p>给定一组互不相同的字符，求这组字符的全排列</p>
</blockquote>
<p>简单场景：<br>
输入的字符串长度为1，显然直接输出即可<br>
问题分解：<br>
当输入的字符长度超过1时只需要从字符串中选一个字符作为输出字符串首字符，对其余的字符进行递归处理即可。</p>
<pre><code>void permutations(string str,int i,int n)
{
    if(i==n-1){
        cout&lt;&lt;str&lt;&lt;endl;
        return;
    }
    for(int j=i;j&lt;n;j++){
        swap(str[i],str[j]);
        permutations(str,i+1,n);
        swap(str[i],str[j]);
    }
    
}
</code></pre>
<h4 id="stirling数">Stirling数</h4>
<blockquote>
<p>n个元素的集合{1,2,...,n}可以划分为若干个非空子集的集合。例如，当n=3时，集合{1,2,3}可以划分为5个不同的非空子集的集合如下：</p>
</blockquote>
<pre><code> {{1},{2},{3}}
 {{1,2},{3}}
 {{1,3},{2}}
 {{2,3},{1}}
 {{1,2,3}}
</code></pre>
<blockquote>
<p>给定正整数n和m，计算出n个元素的集合{1,2,...,n}可以划分为多少个不同的由m个非空子集构成的集合。比如上例中含有1个子集的集合有1个，2个子集的集合有3个，3个自由的集合有1个。</p>
</blockquote>
<p>假定有S(n,m)种方法把n个元素的集合划分成m个非空子集构成的集合，S(n,m)种不同划分方法可以分成一下两类:<br>
先把n-1个元素划分成m个非空子集，按定义其划分数目为S(n-1,m)再将剩下的一个元素插入到m子集种的任意一个,最后把这两部合起来则可构成n个元素集合的m划分，总共有m * S(n-1,m)种划分。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[枚举算法]]></title>
        <id>https://wylovecat.github.io//post/jhWRl2dty</id>
        <link href="https://wylovecat.github.io//post/jhWRl2dty">
        </link>
        <updated>2019-02-26T09:15:19.000Z</updated>
        <content type="html"><![CDATA[<h3 id="基本原理">基本原理</h3>
<blockquote>
<p>按照问题本身的性质，一一列举出该问题的所有可能的解，并在列举的过程中，逐一检验每个可能解是否是问题的真正解。若是则采纳这个解，否则抛弃它。</p>
</blockquote>
<p><strong>tips:</strong></p>
<ul>
<li>不能遗漏，否则导致结果可能不正确</li>
<li>不要重复，否则导致效率低下</li>
</ul>
<p><strong>优点：</strong><br>
问题的解准确且全面<br>
实现简单，可通过循环/递归实现<br>
<strong>缺点：</strong><br>
效率相对来说较低</p>
<p><strong>枚举法解题步骤</strong></p>
<ol>
<li>确定枚举对象</li>
<li>逐一列举可能解</li>
<li>逐一验证可能解</li>
</ol>
<h3 id="经典问题">经典问题</h3>
<h4 id="模糊数字问题">模糊数字问题</h4>
<blockquote>
<p>一张单据上有一个5位数的编码，因为保管不当，其百位已经变得模糊不清。已知这个数是57和67的倍数。现在设计一个算法，输出所有满足这些条件的5位数，并统计这样的数的个数。<br>
1 9 ？9 5</p>
</blockquote>
<p>利用for循环 遍历0-9</p>
<blockquote>
<p>一张单据上有一个5位数的编码，因为保管不当，其百、千、万位已经变得模糊不清。已知这个数是57和67的倍数。现在设计一个算法，输出所有满足这些条件的5位数，并统计这样的数的个数。<br>
？？ ？9 5</p>
</blockquote>
<p>三个枚举对象，使用3层for循环遍历<br>
改进：一个枚举对象，for循环遍历 100-999</p>
<h4 id="百钱百鸡问题">百钱百鸡问题</h4>
<blockquote>
<p>鸡翁一，值钱5；鸡母一，值钱三；鸡雏三，值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？假定鸡种的价格不变，拥有的钱数为m，需要购买的鸡数为n,试求出所有可能的购买方案总数。</p>
</blockquote>
<p>解：<br>
枚举对象(n1-鸡翁,n2-鸡母,n3-鸡雏)</p>
<pre><code>for(n1=0;n1&lt;n;n1++)
    for(n2=0;n2&lt;n;n2++)
        for(n3=0;n3&lt;n;n3++)
            n1+n2+n3==n,5n1+3n2+n3/3==n
</code></pre>
<p>新思路：利用枚举对象之间的线性相关<br>
鸡翁：n1 0~m/5<br>
鸡母：n2 0~m/3<br>
鸡雏：n-n1-n2</p>
<h4 id="数组配对问题">数组配对问题</h4>
<blockquote>
<p>给你一个长度为n的数组A和一个正整数k，问从数组中任选两个数使其和是k的倍数，有多少种选法.</p>
</blockquote>
<p>(ai+aj)%k<mark>0 =&gt; (ai%k+aj%k)%k</mark>0<br>
B0 B1 ... Bk-1<br>
枚举对象：Bij 0&lt;=i&lt;=k-1<br>
逐一列举：for(i=0;i&lt;k;i++)<br>
逐一验证: j=(k-i)%k<br>
Count=bi * bj</p>
<pre><code>#define LL long long
void work()
{
    LL ans=0;
    for(int i=0;i&lt;k;i++)
    {
        int j=(k-i%k;
        if(j&lt;i)break;
        else if(j==i)
            ans+=1LL*a[i]*(a[i]-1)/2;
        else
            ans+=1LL*a[i]*a[j];
        
     }

}
</code></pre>
<h3 id="枚举算法优化技巧">枚举算法优化技巧</h3>
<p>枚举对象优化：<br>
百钱百鸡：参数独立性<br>
数组配对：枚举对象转换<br>
枚举过程优化：<br>
二分枚举的一般模型</p>
<p>给定长度为n的单调不下降数列｛a0,...,an-1｝和目标数k，求满足条件ai&gt;=k的最小值i。不存在的情况下输出n。<br>
枚举对象,0&lt;= i &lt;=n-1<br>
逐一列举<br>
一层for循环，按找i从小到大遍历<br>
逐一验证<br>
判断ai&gt;=k?第一个满足条件的即为答案<br>
更有效的枚举方式<br>
二分法</p>
<h4 id="绳子切割问题">绳子切割问题</h4>
<p>有N条绳子，他们长度分别为Li(&lt;=1000)。如果从他们中切割处K条长度相同的绳子的话，这K条绳子每条最长能有多长?答案保留到小数点后2位。</p>
<p>枚举对象：<br>
L,0.00&lt;=L&lt;=1000.00 步长 0.001</p>
<p>放大100 0-100000<br>
mid=50000</p>
<p>一般化模型</p>
<ol>
<li>“求满足某个条件C(x)的最小的x”,其中C(x)满足性质：如果任意x满足C(x),则所有的x'&gt;=x也满足C(x')</li>
<li>“求满足某个条件C(x)的最大的x”,其中C(x)满足性质：如果任意x满足C(x),则所有的x'&lt;=x也满足C(x')</li>
</ol>
<h4 id="石头移动问题">石头移动问题</h4>
<blockquote>
<p>有一条河，和中间有一些石头，石头的数量以及相邻两块石头之间的距离已知。现在可以一处一些石头，假设最多可以移除m块石头(注意：首尾两块石头不可以移除，且假定所有的石头都处于同一直线)，问最多一时爽m块石头后相邻两块石头之间的最小距离的最大值是多少？</p>
</blockquote>
<p>枚举对象：<br>
StoneSet（S1,S2，...，Sm-1,Sm）<br>
S1 {2,...,n-1}<br>
Si {Si-1 + 1,...,n-1}<br>
逐一列举<br>
循环 m是动态的<br>
递归</p>
<pre><code>#include MaxStone 1000
int globalNum;//石头数量
int globalFlag[MaxBox],globalAns;//保存状态和最优值的全局变量

void recursiveEnum(int t){
    if(t==globalNum){
        int dist=checkStone(globalFlag,globalNum);
        if(dist&gt;globalAns)
            globalAns=dist;
        return;
    }//end of if
    globalFlag[t]=1;
    recursiveFnum(t+1);
    globalFlag[t]=0;
    recursiveEnum(t+1);
}
</code></pre>
<p>改进:二分枚举<br>
问题建模<br>
C(d)描述为：最多移除m个石头后最近两个石头的距离不小于d<br>
C(d)满足单调性：如果任意d满足C(d)，则所有的d'&lt;=d也满足C(d'）<br>
判定：<br>
应用贪心思想：</p>
<ol>
<li>循环一次考虑相邻石头，如果距离小于d，则去掉一个石头</li>
<li>如果任意相邻石头的距离都不小于d，则返回true</li>
<li>如果移除的石头个数大于m,则返回false</li>
</ol>
]]></content>
    </entry>
</feed>