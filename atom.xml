<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wylovecat.github.io/</id>
    <title>咸鱼爱学习</title>
    <updated>2019-09-03T08:46:09.286Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wylovecat.github.io/"/>
    <link rel="self" href="https://wylovecat.github.io//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://wylovecat.github.io//images/avatar.png</logo>
    <icon>https://wylovecat.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 咸鱼爱学习</rights>
    <entry>
        <title type="html"><![CDATA[高精度计算(一)]]></title>
        <id>https://wylovecat.github.io//post/G_OL3h80e</id>
        <link href="https://wylovecat.github.io//post/G_OL3h80e">
        </link>
        <updated>2019-09-03T08:41:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="概述">概述</h1>
<p>当计算的数值非常大或是对于计算的精度要求非常搞事，用已知的数据类型无法精确地表示数值。可以采用数组来模拟大数运算的过程。</p>
<h1 id="高精度加法">高精度加法</h1>
<p>两个大数进行相加计算时，要解决三个问题</p>
<ol>
<li>如何存储</li>
<li>如何计算</li>
<li>如何输出答案</li>
</ol>
<p>先解决第一个问题，数据地存储，由于数据过于庞大，已知的数据类型无法精确地表示数值，会发生数据溢出问题。此时可考虑将数据拆分，将大数分割成若干个0~9数字组成的整体。这样的结构能让我们联想到数组。但是，若是整数数组，在输入时较难将数字存储在各个元素空间内，此时可考虑使用字符串形式进行输入，在存储后再进行转换。</p>
<pre><code>const int maxn=1e10+5;
char s1[maxn]={0},s2[maxn]={0};
cin&gt;&gt;s1&gt;&gt;s2;

</code></pre>
<p>输入完成后，再去考虑计算问题。首先，字符类型直接相加的结果并不正确，需要将其转化为整数数字。可利用ASCII码差值来进行处理。且在进行计算时，模拟竖式加法计算过程，需要从低位开始向高位相加计算且注意过程中的进位。在相加时，加数和被加数位数可能不同，需要低位对齐。实现低位对齐可在转换时进行倒序存放。</p>
<pre><code>// 转换过程
int num[maxn]={0};
int len=strlen(s);

for(int i=0;i&lt;len;i++)
{
    num[i]=s[len-1-i]-'0';
}
</code></pre>
<p>倒序转换好之后，在模拟竖式计算进行处理。注意过程中的进位。</p>
<pre><code>int ans[maxn]={0};
for(int i=0;i&lt;maxLen;i++)
{
	ans[i]+=num1[i]+num2[i];
	ans[i+1]=ans[i]/10;//进位
	ans[i]%=10;//保留余数
}
</code></pre>
<p>计算完成之后可以进行输出，这时候需要注意答案是倒着存放的，需要倒序进行输出并去除前导0;</p>
<pre><code>int flag=0;
for(int i=maxLen+1;i&gt;=0;i--)
{
	if(ans[i]!=0||i==0) flag=1;
    if(falg) cout&lt;&lt;ans[i];
}
</code></pre>
<h1 id="高精度减法">高精度减法</h1>
<p>高精度减法和高精度加法过程类似，字符串输入后模拟竖式进行计算。</p>
<p>前面数据输入和倒置存放的过程相同就不再重复。再计算过程中需要注意的问题就是可能相减会出现负数，两数相减需要考虑绝对值大小问题。</p>
<p>计算a-b,若a&gt;=b,ans=a-b;若a&lt;b,ans=-(b-a);故需要判断大小，可根据长度来判断大小，长度相同则使用字符串比较函数，从字符串内容上进行判断。</p>
<pre><code>int len1=strlen(s1);
int len2=strlen(s2);

if((len1&gt;len2) || (len2==len1&amp;&amp;strcmp(s1,s2)&gt;=0 )
{
    //ans=a-b;
    for(int i=0;i&lt;len1;i++)
    {
        if(num1[i]&lt;num2[i]){
            num1[i]+=10;
            num1[i+1]--;
        }
        ans[i]=num1[i]-num2[i];
    }
}else
{
    //ans=-(b-a);
    for(int i=0;i&lt;len2;i++)
    {
        if(num2[i]&lt;num1[i]){
            num2[i]+=10;
            num2[i+1]--;
        }
        ans[i]=num2[i]-num1[i];
    }
    cout&lt;&lt;&quot;-&quot;;
}
</code></pre>
<p>算完后，再和前面一样进行倒序输出答案，注意删除前导0即可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[欧几里得算法与拓展欧几里得]]></title>
        <id>https://wylovecat.github.io//post/jZSzkJ5Oq</id>
        <link href="https://wylovecat.github.io//post/jZSzkJ5Oq">
        </link>
        <updated>2019-09-02T15:21:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="欧几里得算辗转相除法">欧几里得算(辗转相除法)</h1>
<h2 id="算法描述">算法描述</h2>
<p>设 a&gt;=b</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>÷</mo><mi>b</mi><mo>=</mo><mi>k</mi><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">a \div b = k ······ r    
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span></span></p>
<p>a和b的最大公约数等于b和r的最大公约数。<br>
gcd(a,b)=gcd(b,a%b),当b为0时，a为(a,b)最大公约数</p>
<h2 id="c实现">C++实现</h2>
<pre><code>//递归方式
int gcd(int a,int b)
{
    if(b==0) return a;
    else return gcd(b,a%b);
}

//非递归方式
while(b!=0)
{
    int r=a%b;
    a=b;
    b=r;
}
cout&lt;&lt;a;
</code></pre>
<h2 id="定理证明">定理证明</h2>
<ol>
<li>证明a,b的公约数和 b,r的公约数相同,就能证明最大公约数相同
<ol>
<li>设a = kb+r (a&gt;=b)。由假设可知，r=a mod b。</li>
<li>设d为a和b的任意公约数。</li>
<li>变形可得到式子：r=a-kb,等式两边同除d,可得到式子： r/d = a/d - kb/d =m。</li>
<li>因为d为a,b的公约数，故a/d 为整数，b/d为整数，故r/d也为整数,可推出d为r的约数。故d是b和r的约数。</li>
<li>所以，a和b的任意公约数d,也是b和a%b的公约数。</li>
<li>设 d 是 b,a%b的公约数，则d是b和a-kb的公约数</li>
<li>设b=xd, a-kb=yd（d是他们的约数，他们则可写成d的倍数形式）。则存在a=kb+yd;</li>
<li>将等式两边同除d,a/d =kb/d + y=m。y是整数，d是b的约数，所以m未整数，即d是a的约数。</li>
<li>所以d也是a和b的公约数</li>
<li>综上，(a,b)和(b,a%b)的公约数集合相同，证得(a,b)和(b,a%b)的公约数是一样的</li>
<li>所以最大公约数也相同，证明gcd(a,b)=gcd(b,a%b)</li>
</ol>
</li>
</ol>
<h1 id="拓展欧几里得算法">拓展欧几里得算法</h1>
<h2 id="定理">定理：</h2>
<p>给予两个整数a、b,必存在整数x,y使得ax + by = gcd(a,b)。（贝祖等式）<br>
拓展欧几里得算法就是再辗转相除法的基础上，求的改等式的通解。<br>
x=x0+(b/gcd(a,b)) * t<br>
y=y0-(a/gcd(a,b)) * t<br>
我们知道：a%b = a - (a/b) * b,所以我可以进一步得到<br>
gcd(a,b) = gcd(b, a%b) :<br>
gcd(a%b)=b * x1 + ( a - (a/b)* b)* y1<br>
=b <em>x1 + a</em>y1-(a/b)<em>b</em>y1<br>
= a * y1 +b*(x1-a/b<em>y1)<br>
观察可以发现，x=y1,y=x1-a/b</em> y1<br>
所以我们只要在求解欧几里得的时候同时加上对x,y的更新即可。考虑边界情况，当b=0时，显然此时x=1,y=0;</p>
<h2 id="代码实现">代码实现</h2>
<pre><code>int ex_gcd(int a,int b,int &amp;x,int &amp;y)
{
   if(b==0) {x=1;y=0;return a;}
   int ans=ex_gcd(b,a%b,x,y);
   int t=x;
   x=y;
   y=t-a/b*y;
   return ans;
 }
 
 //精简
 int ex_gcd(int a,int b,int &amp;x,int &amp;y)
 {
   if(b==0) {x=1;y=0;return a;}
   int ans=ex_gcd(b,a%b,y,x);
   y-=(a/b)*x;
   return ans;
 }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[比例简化]]></title>
        <id>https://wylovecat.github.io//post/dLtINUDHC</id>
        <link href="https://wylovecat.github.io//post/dLtINUDHC">
        </link>
        <updated>2019-08-17T02:19:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目阅读">题目阅读</h3>
<p><a href="https://turingjudge.com/problem/1805">比例简化</a></p>
<h3 id="分析">分析</h3>
<p>现给出支持人数A，反对人数B，以及一个上限L，请你将A比B化简为A’比B’，要求在A’和B’均不大于L且A’和B’互质（两个整数的最大公约数是1）的前提下，A’/B’≥ A/B且A’/B’- A/B的值尽可能小</p>
<p>整理几个关键信息点</p>
<ul>
<li>在A’和B’均不大于L且A’和B’互质</li>
</ul>
<p>a&lt;=L &amp;&amp; b&lt;=L &amp;&amp; gcd(a,b)==1</p>
<ul>
<li>A’/B’≥ A/B且A’/B’- A/B的值尽可能小</li>
</ul>
<p>a/b&gt;=A/B =&gt; a * B &gt;= A *  b &amp;&amp;  a/b 尽可能小</p>
<p>分析下来就是一道枚举题目，寻找满足条件的最小的a/b的值最小的那对a,b;变成了最值寻找问题</p>
<pre><code class="language-c++">int min=max;
for( )
{
	if(num&lt;min)
	{
		min=num;
	}
}
cout&lt;&lt;num;
</code></pre>
<pre><code class="language-c++">ta=L,tb=1;
for(int a=1;a&lt;=L;a++)
{
    for(int b=L;b&gt;=1;b--)
    {
        if(gcd(a,b)==1 &amp;&amp; a*B&gt;=A*b &amp;&amp; a*tb&lt;ta*b)
        {
            ta=a;
            tb=b;
            break;
        }
    }
}
cout&lt;&lt;ta&lt;&lt;&quot; &quot;&lt;&lt;tb;
</code></pre>
<h3 id="ac代码">AC代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
/*
 * a&lt;=L&amp;&amp;b&lt;=L&amp;&amp;gcd(a,b)==1
 *  a/b&gt;=A/B =》 a*B &gt;= A*b  &amp;&amp; a/b - A/B 尽可能小
 *  1~100 =》 L   a/b&lt;=L   a&lt;=L*b   b&gt;=a/L
 *
 *  a/b &lt;ta/tb
 *
 *  枚举
 * */

int gcd(int a,int b)
{
    while(b!=0)
    {
        int r=a%b;
        a=b;
        b=r;
    }
    return a;
}
int main(){

    int A,B,L;
    cin&gt;&gt;A&gt;&gt;B&gt;&gt;L;
    int y=gcd(A,B);
    A/=y;
    B/=y;
    int ta=L;
    int tb=1;
    for(int a=1;a&lt;=L;a++)
    {
        for(int b=L;b&gt;=a/L;b--)
        {
            if(gcd(a,b)==1 &amp;&amp; a*B&gt;=A*b &amp;&amp; a*tb&lt;=ta*b)
            {
                ta=a;
                tb=b;
                break;
            }
        }
    }
    cout&lt;&lt;ta&lt;&lt;&quot; &quot;&lt;&lt;tb;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[珠心算测验]]></title>
        <id>https://wylovecat.github.io//post/S-SCKDM5o</id>
        <link href="https://wylovecat.github.io//post/S-SCKDM5o">
        </link>
        <updated>2019-08-15T07:14:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p><a href="https://turingjudge.com/problem/1804">珠心算测验</a></p>
<h2 id="阅读与分析">阅读与分析</h2>
<p>集合中的各个与手持不相同。求有多少个数恰好等于集合中另外两个（不同的）数之和。</p>
<p>注意：题目求的是数字的个数不是，满足条件的式子的个数入，3+4=7，2+5=7，个数只有1不是2。</p>
<p>整体分析下来是将不同的两数相加，将结果和剩下的数字比对，不同的就统计下即可。</p>
<pre><code class="language-c++">for(i:0~n)
{
	for(j:i~n)
	{
		for(k:j~n)
		{
			if(i+j==k &amp;&amp; num[k]==0)
			{
				s++;
				num[k]=1;
			}
		}
	}
}
</code></pre>
<h2 id="ac-代码">AC 代码</h2>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;
int num[10005]={0};
int a[200]={0},n;

int main() {
    int s=0;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;a[i];
        num[a[i]]=1;
    }

    for(int i=1;i&lt;=n;i++)
    {
        for(int j=i+1;j&lt;=n;j++)
        {
            int m=a[i]+a[j];
            if(m&lt;=10000 &amp;&amp; num[m]==1)// 限制总和范围，不然会越界
            {
                s++;
                num[m]=2;
            }
        }
    }
    cout&lt;&lt;s;


    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[回文日期]]></title>
        <id>https://wylovecat.github.io//post/8o-Bcw0Hg</id>
        <link href="https://wylovecat.github.io//post/8o-Bcw0Hg">
        </link>
        <updated>2019-08-15T05:46:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p><a href="https://turingjudge.com/problem/1846">回文日期</a></p>
<h2 id="阅读与分析">阅读与分析</h2>
<p>用8位数字表示日期，前4位表示年份，接下来2位表示月份，最后2位代表日期。对范围内的日期进行回文日期的统计。若一个日期是回文的，当且仅当对于所有的i从左向有的第i个数字和第9-i个数字是相同的。</p>
<p>输入起止日期，统计多少个日期是回文的。</p>
<p>阅读下来，题目梗概即为在一定范围内统计符合条件的数字个数，即可想到使用枚举法进行处理</p>
<p>基本框架如下。</p>
<pre><code class="language-c++">for(int i:date1~date2)
{
	if(isPali(i))
	{
		num++;
	}
}
</code></pre>
<p>问题变成，如何判断一个日期是回文的。</p>
<p>一个思路是将8位数日期的倒序数求出将倒序数与原数比较，相等即是回文。</p>
<p>另一个思路，将回文日期列举，能发现 20100102，20111102，月日组成的倒数和年相等即是回文。</p>
<p>此外需要注意，日期必须得是真实存在的。修改框架如下：</p>
<pre><code class="language-c++">for(int i:date1~date2)
{
	if(isReal(i)&amp;&amp;isPali(i))
	{
		num++;
	}
}
</code></pre>
<h2 id="ac代码">AC代码</h2>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

int months[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};

bool isLeap(int year)
{
    return (year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0;
}

bool isPali(int date)
{
    int y=date/10000;

    int reserve=0;
    while(date!=y)
    {
        int u=date%10;
        date/=10;
        reserve= reserve * 10 + u;
    }
    return reserve == y;

}

bool isReal(int date)
{
    int y=date/10000;
    int m=date/100%100;
    int d=date%100;

    if(isLeap(y))
    {
        months[2]=29;
    }else
    {
        months[2]=28;
    }

    return (m &gt;= 1 &amp;&amp; m &lt;= 12) &amp;&amp; (d &gt;= 1 &amp;&amp; d &lt;= months[m]);
}

int main() {

    int date1,date2,num=0;
    cin&gt;&gt;date1&gt;&gt;date2;
    for(int i=date1;i&lt;=date2;i++)
    {
        if(isReal(i)&amp;&amp;isPali(i))
        {
            num++;
        }
    }
    cout&lt;&lt;num;

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[有趣的GitHub项目]]></title>
        <id>https://wylovecat.github.io//post/UukfogPTY</id>
        <link href="https://wylovecat.github.io//post/UukfogPTY">
        </link>
        <updated>2019-07-14T07:44:23.000Z</updated>
        <summary type="html"><![CDATA[<p>分享一些有趣、有用的GitHub项目。</p>
]]></summary>
        <content type="html"><![CDATA[<p>分享一些有趣、有用的GitHub项目。</p>
<!--more-->
<h3 id="git的奇技淫巧">Git的奇技淫巧</h3>
<p>https://github.com/521xueweihan/git-tips</p>
<p>列举了Git常用的命令和一些小技巧。</p>
<h3 id="gridea">Gridea</h3>
<p>https://github.com/getgridea/gridea</p>
<p>一个静态博客写作客户端。用了它我就抛弃了Hexo。作者更新的很勤快。</p>
<h3 id="待续">待续</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用fgets()替换gets()]]></title>
        <id>https://wylovecat.github.io//post/Y4cNdIzTy</id>
        <link href="https://wylovecat.github.io//post/Y4cNdIzTy">
        </link>
        <updated>2019-05-06T09:10:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="原因">原因</h3>
<blockquote>
<p>gets()函数不太安全，容易出现数组溢出问题。</p>
</blockquote>
<h3 id="举例">举例：</h3>
<pre><code>char name[3];
gets(name);

假设我输入&quot;wangxiaoming&quot;，很明显长度超出限制，但是gets()不会对其进行检查。
</code></pre>
<p><strong>使用fgets()来进行更安全的输入。</strong></p>
<h3 id="描述">描述</h3>
<blockquote>
<p>C 库函数 char <em>fgets(char</em> str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</p>
</blockquote>
<h3 id="声明">声明</h3>
<p>下面是 fgets() 函数的声明。</p>
<blockquote>
<p>char <em>fgets(char</em> str, int n, FILE *stream)</p>
</blockquote>
<h3 id="参数">参数</h3>
<p><strong>str</strong> -- 这是指向一个字符数组的指针，该数组存储了要读取的字符串。</p>
<p><strong>n</strong> -- 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。</p>
<p><strong>stream</strong> -- 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。</p>
<h3 id="返回值">返回值</h3>
<ul>
<li>如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。</li>
<li>如果发生错误，返回一个空指针。</li>
</ul>
<h3 id="使用举例">使用举例</h3>
<pre><code class="language-c++">char name[len];
fgets(name,len,stdin);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[升级DevC++的编译器]]></title>
        <id>https://wylovecat.github.io//post/1M3vM-kJi</id>
        <link href="https://wylovecat.github.io//post/1M3vM-kJi">
        </link>
        <updated>2019-04-23T07:45:40.000Z</updated>
        <content type="html"><![CDATA[<hr>
<h2 id="前言">前言</h2>
<p>DevC++是采用MinGW来作为C/C++的编译器的，但是由于多年未更新，版本老旧。当然，我们可以继续使用它来进行相关内容学习，如果想对编译器进行更新可以自己下载最新版本的MinGW进行替换。</p>
<h2 id="安装mingw">安装MinGW</h2>
<p>MinGW可使用<a href="https://sourceforge.net/projects/mingw/">MinGW Installation Manager</a>进行安装，但是由于资源在境外下载速度比较慢，且在安装后发现版本是在三年前的，虽然比DevC++的新一些。所以推荐采用另一种安装方式<a href="https://nuwen.net/mingw.html#install">MinGW Distro</a>。这个是GCC 8.2.0版本的，并且要用的包全都已经打包好了，下载完成解压即可使用。下载页面分两个，如果在电脑上已经安装好Git可以下载<a href="https://nuwen.net/files/mingw/mingw-16.1-without-git.exe">without-git</a>版本，如果没有就下载<a href="https://nuwen.net/files/mingw/mingw-16.1.exe">完整</a>的就行。</p>
<p>解压完成后可手动进行环境配置，或者运行里面的自带的bat脚本进行配置。配置完成后打开命令行窗口，输入gcc -v查看版本，观察是否已经成功配置。</p>
<p><img src="https://cdn.all-dream.com/user/24ea64ea3b034d4ea442e522a4692266/20190423_154705_gcc.png" alt="gcc -v"></p>
<p>出现上图所示内容代表已经配置成功。</p>
<h2 id="替换编译器">替换编译器</h2>
<p>打开DevC++，点击工具-编译环境，在设定编译器配置时，点击第二个绿色加号（由文件夹添加编译器配置），选择我们刚刚解压的MinGW文件夹，他会自动进行配置，点击确定即可完成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[进制转换]]></title>
        <id>https://wylovecat.github.io//post/ZigeFxfIY</id>
        <link href="https://wylovecat.github.io//post/ZigeFxfIY">
        </link>
        <updated>2019-04-19T09:37:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="进制转换">进制转换</h1>
<h2 id="基础">基础</h2>
<p>十进制与二进制的转换是基础内容，应做到熟练地将十进制的数转为二进制，将二进制的数转为十进制。</p>
<h3 id="十进制转二进制">十进制转二进制</h3>
<h4 id="整数转二进制">整数转二进制</h4>
<p>整数转二进制是最常见的。核心在于除2取余，倒序排列，高位补零。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/292435/1554633400474-fdf7c01e-f32e-435f-8a9c-a75a7ec3774c.png#align=left&amp;display=inline&amp;height=332&amp;name=image.png&amp;originHeight=664&amp;originWidth=1184&amp;size=87756&amp;status=done&amp;width=592" alt="image.png"><br />不断地将数字除以2，将余数写一边，直到商为0时，停止。下方的为二进制的高位，由高位到低位倒序排列余数，高位不够用0来代替。</p>
<h4 id="负整数转二进制">负整数转二进制</h4>
<p>先是将对应的正整数转换成二进制后，对二进制取反然后再加1。以-10为例。10的二进制表达是(00001010),由于高位都是0，所以可以省略，写成(1010) ,（用B来表示表达的是二进制）。</p>
<ol>
<li>先取反。取反的意思就是1变成0，0变成1。(00001010)=&gt;(11110101)</li>
<li>加上1。由于是二进制，所以我们逢二进一。(11110101)=&gt;(11110110)</li>
</ol>
<p>由于小数的高位都是1，所以我们也可以将高位省去，只保留(0110)不过注意和正整数进行区别。</p>
<h4 id="小数转二进制">小数转二进制</h4>
<p>将小数部分乘以2，取整数(这个整数不是0就是1)，当乘以二后小数部分结果为0或者位数够了，这些整数就是二进制。<br />以0.125为例<br />0.125 * 2 =0.25 整数部分为 0<br />0.25 *  2  = 0.5  整数部分为 0<br />0.5  *  2  = 1.0  整数部分为1，小数部分为0，停止。<br />二进制就为0.001<br />如果是带整数部分的小数进行进制转换，那么分开来处理，先将整数部分，转换成二进制，再将小数部分，转为二进制。<br />**注意 **小数进行二进制转换是存在无法除尽的情况的，这是正常的。根据题意保留足够的位数即可。</p>
<h3 id="二进制转十进制">二进制转十进制</h3>
<p>使用按权相加法。</p>
<h4 id="高位为0">高位为0</h4>
<p>首先第一步将位数补齐，如果高位是0则是一个正数。将其分离位数，将分离出来的位数按从低位到高位的顺数，依次和2的冥相乘累加。以(1010)为例。<br />分离位数： 1 0 1 0  =》相乘累加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>×</mo><msup><mn>2</mn><mn>0</mn></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><mn>0</mn><mo>×</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">0\times2^{0}+1\times2^{1}+0\times2^{2}+1\times2^{3}=10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></p>
<h4 id="高位为1">高位为1</h4>
<p>如果高位为1，则说明是一个负数，那就先减1，再进行取反，在进行转换。以(11110110)<br />减一：(11110101) =&gt; 取反: (00001010)=&gt;按权相加:0<em>2+1</em>2+0<em>2+1</em>2=10</p>
<h4 id="小数形式">小数形式</h4>
<p>整数部分和小数部分分开计算。整数部分参考上面。小数部分则是相反。以（0.001）为例。<br />按权相加：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>0</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup><mo>=</mo><mn>0.125</mn></mrow><annotation encoding="application/x-tex">0\times2^{-1}+0\times2^{-2}+1\times2^{-3}=0.125</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span></span></span></span></p>
<h2 id="其他进制转换">其他进制转换</h2>
<p>整体上的方法和十进制与二进制的转换方法类似。转换成x进制的话使用除x取余，倒序排列，高位补零。二进制转换成其他进制还是采用按权相加的方法。</p>
<h3 id="八进制与十六进制">八进制与十六进制</h3>
<p>八进制是逢八进一。</p>
<p>十进制转八进制的话，过程就是不断地将数字除以8，将余数写一边，直到商为0时停止。下方的为二进制的高位，由高位到低位倒序排列余数，高位不够用0来代替。以十进制10转换为八进制例。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/292435/1554693614581-4e24b0dc-9e94-4acf-889f-89617bbcc24d.png" alt="image.png"></p>
<p>十六进制也是类似，需要注意的点是，十六进制的10<sub>15是使用A</sub>F来表示的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[递归与分治（一）]]></title>
        <id>https://wylovecat.github.io//post/Hkqr-7jgZ</id>
        <link href="https://wylovecat.github.io//post/Hkqr-7jgZ">
        </link>
        <updated>2019-03-01T02:50:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="递归基本思想">递归基本思想</h3>
<p><strong>基本要素</strong></p>
<ol>
<li>递归终止条件</li>
<li>终止处理办法</li>
<li>递归处理办法</li>
</ol>
<p><strong>递归-阶乘</strong><br>
阶乘计算：从键盘输入正整数N（0&lt;=N&lt;=20）,输出N！。</p>
<pre><code>int factorial(int n){
    if(n==0
        return 1;//递归边界
    return n*factorial(n-1);//递归调用
 }
</code></pre>
<p><strong>递归-Fibonacci</strong><br>
每对兔子每个月不多不少恰好能生一对(一雌一雄)新兔子，而且每对新生兔出生两个月后就成熟并具备生殖能力；另外，假定所有的兔子都不会死亡。假如养了出生的小兔一对，试问第n个月后共有多少对兔子?</p>
<pre><code>long fib(int n){
    if(n&lt;=1) return 1;
    return fib(n-1)+fib(n-2);
}
</code></pre>
<h3 id="递归实例">递归实例</h3>
<h4 id="全排列问题">全排列问题</h4>
<blockquote>
<p>给定一组互不相同的字符，求这组字符的全排列</p>
</blockquote>
<p>简单场景：<br>
输入的字符串长度为1，显然直接输出即可<br>
问题分解：<br>
当输入的字符长度超过1时只需要从字符串中选一个字符作为输出字符串首字符，对其余的字符进行递归处理即可。</p>
<pre><code>void permutations(string str,int i,int n)
{
    if(i==n-1){
        cout&lt;&lt;str&lt;&lt;endl;
        return;
    }
    for(int j=i;j&lt;n;j++){
        swap(str[i],str[j]);
        permutations(str,i+1,n);
        swap(str[i],str[j]);
    }
    
}
</code></pre>
<h4 id="stirling数">Stirling数</h4>
<blockquote>
<p>n个元素的集合{1,2,...,n}可以划分为若干个非空子集的集合。例如，当n=3时，集合{1,2,3}可以划分为5个不同的非空子集的集合如下：</p>
</blockquote>
<pre><code> {{1},{2},{3}}
 {{1,2},{3}}
 {{1,3},{2}}
 {{2,3},{1}}
 {{1,2,3}}
</code></pre>
<blockquote>
<p>给定正整数n和m，计算出n个元素的集合{1,2,...,n}可以划分为多少个不同的由m个非空子集构成的集合。比如上例中含有1个子集的集合有1个，2个子集的集合有3个，3个自由的集合有1个。</p>
</blockquote>
<p>假定有S(n,m)种方法把n个元素的集合划分成m个非空子集构成的集合，S(n,m)种不同划分方法可以分成一下两类:<br>
先把n-1个元素划分成m个非空子集，按定义其划分数目为S(n-1,m)再将剩下的一个元素插入到m子集种的任意一个,最后把这两部合起来则可构成n个元素集合的m划分，总共有m * S(n-1,m)种划分。</p>
]]></content>
    </entry>
</feed>